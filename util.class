package com.herocraftonline.heroes.util;

import com.herocraftonline.heroes.Heroes;
import com.herocraftonline.heroes.characters.Hero;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.math.BigDecimal;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map.Entry;
import java.util.Random;
import java.util.Set;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.Server;
import org.bukkit.World;
import org.bukkit.block.Block;
import org.bukkit.enchantments.Enchantment;
import org.bukkit.entity.Entity;
import org.bukkit.entity.LivingEntity;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.PlayerInventory;
import org.bukkit.scheduler.BukkitScheduler;

public final class Util
{
  public static final List<String> swords;
  public static final List<String> axes;
  public static final List<String> shovels;
  public static final List<String> picks;
  public static final List<String> hoes;
  public static final List<String> weapons;
  public static final List<String> armors;
  public static final List<String> tools;
  public static final Set<Material> interactableBlocks;
  public static final HashSet<Byte> interactableIds;
  public static final Set<Material> transparentBlocks;
  public static final HashSet<Byte> transparentIds;
  private static final Random rand = new SecureRandom();

  public static final HashMap<String, Location> deaths = new LinkedHashMap()
  {
    private static final int MAX_ENTRIES = 50;

    protected boolean removeEldestEntry(Map.Entry eldest)
    {
      return size() > 50;
    }
  };

  static
  {
    swords = new ArrayList(5);
    swords.add("WOOD_SWORD");
    swords.add("STONE_SWORD");
    swords.add("IRON_SWORD");
    swords.add("GOLD_SWORD");
    swords.add("DIAMOND_SWORD");

    axes = new ArrayList(5);
    axes.add("WOOD_AXE");
    axes.add("STONE_AXE");
    axes.add("IRON_AXE");
    axes.add("GOLD_AXE");
    axes.add("DIAMOND_AXE");

    shovels = new ArrayList(5);
    shovels.add("WOOD_SPADE");
    shovels.add("STONE_SPADE");
    shovels.add("IRON_SPADE");
    shovels.add("GOLD_SPADE");
    shovels.add("DIAMOND_SPADE");

    picks = new ArrayList(5);
    picks.add("WOOD_PICKAXE");
    picks.add("STONE_PICKAXE");
    picks.add("IRON_PICKAXE");
    picks.add("GOLD_PICKAXE");
    picks.add("DIAMOND_PICKAXE");

    hoes = new ArrayList(5);
    hoes.add("WOOD_HOE");
    hoes.add("STONE_HOE");
    hoes.add("IRON_HOE");
    hoes.add("GOLD_HOE");
    hoes.add("DIAMOND_HOE");

    tools = new ArrayList(2);
    tools.add("SHEARS");
    tools.add("FISHING_ROD");
    tools.add("CARROT_STICK");
    tools.addAll(shovels);
    tools.addAll(hoes);

    weapons = new ArrayList(26);
    weapons.addAll(picks);
    weapons.addAll(axes);
    weapons.addAll(swords);
    weapons.addAll(tools);
    weapons.add("BOW");

    armors = new ArrayList(21);
    armors.add("LEATHER_HELMET");
    armors.add("LEATHER_LEGGINGS");
    armors.add("LEATHER_BOOTS");
    armors.add("LEATHER_CHESTPLATE");
    armors.add("IRON_HELMET");
    armors.add("IRON_LEGGINGS");
    armors.add("IRON_CHESTPLATE");
    armors.add("IRON_BOOTS");
    armors.add("CHAINMAIL_HELMET");
    armors.add("CHAINMAIL_LEGGINGS");
    armors.add("CHAINMAIL_BOOTS");
    armors.add("CHAINMAIL_CHESTPLATE");
    armors.add("GOLD_HELMET");
    armors.add("GOLD_LEGGINGS");
    armors.add("GOLD_CHESTPLATE");
    armors.add("GOLD_BOOTS");
    armors.add("DIAMOND_HELMET");
    armors.add("DIAMOND_LEGGINGS");
    armors.add("DIAMOND_CHESTPLATE");
    armors.add("DIAMOND_BOOTS");
    armors.add("PUMPKIN");
    armors.add("SKULL_ITEM");
    armors.add("MAGE1_HELMET");
    armors.add("MAGE1_LEGGINGS");
    armors.add("MAGE1_CHESTPLATE");
    armors.add("MAGE1_BOOTS");
    armors.add("MAGE2_HELMET");
    armors.add("MAGE2_LEGGINGS");
    armors.add("MAGE2_CHESTPLATE");
    armors.add("MAGE2_BOOTS");
    armors.add("WARRIOR1_HELMET");
    armors.add("WARRIOR1_LEGGINGS");
    armors.add("WARRIOR1_CHESTPLATE");
    armors.add("WARRIOR1_BOOTS");
    armors.add("WARRIOR2_HELMET");
    armors.add("WARRIOR2_LEGGINGS");
    armors.add("WARRIOR2_CHESTPLATE");
    armors.add("WARRIOR2_BOOTS");
    armors.add("ROGUE1_HELMET");
    armors.add("ROGUE1_LEGGINGS");
    armors.add("ROGUE1_CHESTPLATE");
    armors.add("ROGUE1_BOOTS");
    armors.add("ROGUE2_HELMET");
    armors.add("ROGUE2_LEGGINGS");
    armors.add("ROGUE2_CHESTPLATE");
    armors.add("ROGUE2_BOOTS");
    armors.add("CLERIC1_HELMET");
    armors.add("CLERIC1_LEGGINGS");
    armors.add("CLERIC1_CHESTPLATE");
    armors.add("CLERIC1_BOOTS");
    armors.add("CLERIC2_HELMET");
    armors.add("CLERIC2_LEGGINGS");
    armors.add("CLERIC2_CHESTPLATE");
    armors.add("CLERIC2_BOOTS");

    interactableBlocks = new HashSet(40);
    interactableBlocks.add(Material.CHEST);
    interactableBlocks.add(Material.LOCKED_CHEST);
    interactableBlocks.add(Material.IRON_DOOR_BLOCK);
    interactableBlocks.add(Material.SIGN);
    interactableBlocks.add(Material.WALL_SIGN);
    interactableBlocks.add(Material.SIGN_POST);
    interactableBlocks.add(Material.WORKBENCH);
    interactableBlocks.add(Material.STONE_BUTTON);
    interactableBlocks.add(Material.WOOD_BUTTON);
    interactableBlocks.add(Material.LEVER);
    interactableBlocks.add(Material.WOODEN_DOOR);
    interactableBlocks.add(Material.TRAP_DOOR);
    interactableBlocks.add(Material.TRAPPED_CHEST);
    interactableBlocks.add(Material.DIODE);
    interactableBlocks.add(Material.DIODE_BLOCK_ON);
    interactableBlocks.add(Material.DIODE_BLOCK_OFF);
    interactableBlocks.add(Material.DISPENSER);
    interactableBlocks.add(Material.HOPPER);
    interactableBlocks.add(Material.DROPPER);
    interactableBlocks.add(Material.REDSTONE_COMPARATOR);
    interactableBlocks.add(Material.REDSTONE_COMPARATOR_ON);
    interactableBlocks.add(Material.REDSTONE_COMPARATOR_OFF);
    interactableBlocks.add(Material.FURNACE);
    interactableBlocks.add(Material.BURNING_FURNACE);
    interactableBlocks.add(Material.CAULDRON);
    interactableBlocks.add(Material.JUKEBOX);
    interactableBlocks.add(Material.NOTE_BLOCK);
    interactableBlocks.add(Material.STORAGE_MINECART);
    interactableBlocks.add(Material.ENDER_CHEST);
    interactableBlocks.add(Material.FENCE_GATE);
    interactableBlocks.add(Material.ENCHANTMENT_TABLE);
    interactableBlocks.add(Material.BREWING_STAND);
    interactableBlocks.add(Material.ITEM_FRAME);
    interactableBlocks.add(Material.BOAT);
    interactableBlocks.add(Material.MINECART);
    interactableBlocks.add(Material.FLOWER_POT);
    interactableBlocks.add(Material.BEACON);
    interactableBlocks.add(Material.BED_BLOCK);
    interactableBlocks.add(Material.ANVIL);
    interactableBlocks.add(Material.COMMAND);

    interactableIds = new HashSet(40);
    interactableIds.add(Byte.valueOf((byte)Material.CHEST.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.LOCKED_CHEST.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.IRON_DOOR_BLOCK.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.SIGN.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.WALL_SIGN.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.SIGN_POST.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.WORKBENCH.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.STONE_BUTTON.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.WOOD_BUTTON.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.LEVER.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.WOODEN_DOOR.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.TRAP_DOOR.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.TRAPPED_CHEST.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.DIODE.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.DIODE_BLOCK_ON.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.DIODE_BLOCK_OFF.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.DISPENSER.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.HOPPER.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.DROPPER.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.REDSTONE_COMPARATOR.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.REDSTONE_COMPARATOR_ON.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.REDSTONE_COMPARATOR_OFF.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.FURNACE.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.BURNING_FURNACE.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.CAULDRON.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.JUKEBOX.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.NOTE_BLOCK.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.STORAGE_MINECART.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.ENDER_CHEST.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.FENCE_GATE.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.ENCHANTMENT_TABLE.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.BREWING_STAND.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.ITEM_FRAME.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.BOAT.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.MINECART.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.FLOWER_POT.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.BEACON.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.BED_BLOCK.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.ANVIL.getId()));
    interactableIds.add(Byte.valueOf((byte)Material.COMMAND.getId()));

    transparentBlocks = new HashSet(26);
    transparentBlocks.add(Material.AIR);
    transparentBlocks.add(Material.SNOW);
    transparentBlocks.add(Material.TRIPWIRE);
    transparentBlocks.add(Material.REDSTONE_WIRE);
    transparentBlocks.add(Material.TORCH);
    transparentBlocks.add(Material.REDSTONE_TORCH_OFF);
    transparentBlocks.add(Material.REDSTONE_TORCH_ON);
    transparentBlocks.add(Material.RED_ROSE);
    transparentBlocks.add(Material.YELLOW_FLOWER);
    transparentBlocks.add(Material.SAPLING);
    transparentBlocks.add(Material.LADDER);
    transparentBlocks.add(Material.STONE_PLATE);
    transparentBlocks.add(Material.WOOD_PLATE);
    transparentBlocks.add(Material.CROPS);
    transparentBlocks.add(Material.LEVER);
    transparentBlocks.add(Material.WATER);
    transparentBlocks.add(Material.STATIONARY_WATER);
    transparentBlocks.add(Material.RAILS);
    transparentBlocks.add(Material.POWERED_RAIL);
    transparentBlocks.add(Material.DETECTOR_RAIL);
    transparentBlocks.add(Material.DIODE_BLOCK_OFF);
    transparentBlocks.add(Material.DIODE_BLOCK_ON);
    transparentBlocks.add(Material.CARPET);
    transparentBlocks.add(Material.VINE);
    transparentBlocks.add(Material.DEAD_BUSH);
    transparentBlocks.add(Material.WATER_LILY);

    transparentIds = new HashSet(26);
    transparentIds.add(Byte.valueOf((byte)Material.AIR.getId()));
    transparentIds.add(Byte.valueOf((byte)Material.SNOW.getId()));
    transparentIds.add(Byte.valueOf((byte)Material.TRIPWIRE.getId()));
    transparentIds.add(Byte.valueOf((byte)Material.REDSTONE_WIRE.getId()));
    transparentIds.add(Byte.valueOf((byte)Material.TORCH.getId()));
    transparentIds.add(Byte.valueOf((byte)Material.REDSTONE_TORCH_OFF.getId()));
    transparentIds.add(Byte.valueOf((byte)Material.REDSTONE_TORCH_ON.getId()));
    transparentIds.add(Byte.valueOf((byte)Material.RED_ROSE.getId()));
    transparentIds.add(Byte.valueOf((byte)Material.YELLOW_FLOWER.getId()));
    transparentIds.add(Byte.valueOf((byte)Material.SAPLING.getId()));
    transparentIds.add(Byte.valueOf((byte)Material.LADDER.getId()));
    transparentIds.add(Byte.valueOf((byte)Material.STONE_PLATE.getId()));
    transparentIds.add(Byte.valueOf((byte)Material.WOOD_PLATE.getId()));
    transparentIds.add(Byte.valueOf((byte)Material.CROPS.getId()));
    transparentIds.add(Byte.valueOf((byte)Material.LEVER.getId()));
    transparentIds.add(Byte.valueOf((byte)Material.WATER.getId()));
    transparentIds.add(Byte.valueOf((byte)Material.STATIONARY_WATER.getId()));
    transparentIds.add(Byte.valueOf((byte)Material.RAILS.getId()));
    transparentIds.add(Byte.valueOf((byte)Material.POWERED_RAIL.getId()));
    transparentIds.add(Byte.valueOf((byte)Material.DETECTOR_RAIL.getId()));
    transparentIds.add(Byte.valueOf((byte)Material.DIODE_BLOCK_OFF.getId()));
    transparentIds.add(Byte.valueOf((byte)Material.DIODE_BLOCK_ON.getId()));
    transparentIds.add(Byte.valueOf((byte)Material.CARPET.getId()));
    transparentIds.add(Byte.valueOf((byte)Material.VINE.getId()));
    transparentIds.add(Byte.valueOf((byte)Material.DEAD_BUSH.getId()));
    transparentIds.add(Byte.valueOf((byte)Material.WATER_LILY.getId()));
  }

  public static double getDefaultMaxHealth(LivingEntity entity)
  {
    switch ($SWITCH_TABLE$org$bukkit$entity$EntityType()[entity.getType().ordinal()])
    {
    case 44:
      return 4.0D;
    case 43:
      return 10.0D;
    case 24:
      return 100.0D;
    case 30:
      return 1200.0D;
    case 27:
      return 50000.0D;
    case 25:
    case 29:
    case 31:
    case 41:
    case 42:
    case 49:
      return 200.0D;
    case 26:
      return 800.0D;
    case 45:
      return 60.0D;
    case 51:
      return 7000.0D;
    case 28:
    case 32:
    case 33:
    case 37:
    case 46:
      return 1000.0D;
    case 34:
    case 52:
      return 800.0D;
    case 35:
      return 600.0D;
    case 47:
      return 400.0D;
    case 40:
      return 8.0D;
    case 38:
    case 39:
    case 48:
      return 400.0D;
    case 36:
    case 50:
    }return 46464.0D;
  }

  public static double getDefaultDamage(Material item)
  {
    switch ($SWITCH_TABLE$org$bukkit$Material()[item.ordinal()]) {
    case 1:
    case 179:
    case 182:
    case 194:
      return 2.0D;
    case 165:
    case 180:
    case 183:
    case 195:
      return 3.0D;
    case 166:
    case 177:
    case 184:
    case 186:
    case 192:
      return 4.0D;
    case 167:
    case 181:
    case 187:
      return 5.0D;
    case 176:
    case 188:
      return 6.0D;
    case 185:
      return 7.0D;
    }
    return 10.0D;
  }

  public static boolean isNearSpawner(Entity entity, int radius)
  {
    Location location = entity.getLocation();

    for (int i = 0 - radius; i <= radius; i++) {
      for (int j = 0 - radius; j <= radius; j++) {
        for (int k = 0 - radius; k <= radius; k++) {
          if (location.getBlock().getRelative(i, j, k).getType().equals(Material.MOB_SPAWNER)) {
            return true;
          }
        }
      }
    }
    return false;
  }

  public static int firstEmpty(ItemStack[] inventory)
  {
    for (int i = 9; i < inventory.length; i++) {
      if (inventory[i] == null) {
        return i;
      }
    }
    return -1;
  }

  public static boolean moveItem(Hero hero, int slot, ItemStack item)
  {
    Player player = hero.getPlayer();
    PlayerInventory inv = player.getInventory();
    int empty = firstEmpty(inv.getContents());
    if (empty == -1) {
      player.getWorld().dropItemNaturally(player.getLocation(), item);
      if (slot != -1) {
        inv.clear(slot);
      }
      return false;
    }
    inv.setItem(empty, item);
    if (slot != -1) {
      inv.clear(slot);
    }
    Messaging.send(player, "Вы не обучены использовать $1.", new Object[] { MaterialUtil.getFriendlyName(item.getType()) });
    return true;
  }

  public static void syncInventory(Player player, Heroes plugin)
  {
    plugin.getServer().getScheduler().scheduleSyncDelayedTask(plugin, new Runnable()
    {
      public void run()
      {
        Util.this.updateInventory();
      }
    });
  }

  public static boolean isWeapon(Material mat)
  {
    switch ($SWITCH_TABLE$org$bukkit$Material()[mat.ordinal()]) {
    case 165:
    case 166:
    case 167:
    case 170:
    case 176:
    case 177:
    case 178:
    case 179:
    case 180:
    case 181:
    case 182:
    case 183:
    case 184:
    case 185:
    case 186:
    case 187:
    case 188:
    case 192:
    case 193:
    case 194:
    case 195:
    case 199:
    case 200:
    case 201:
    case 202:
    case 203:
    case 287:
    case 300:
      return true;
    }
    return false;
  }

  public static boolean isAwkwardWeapon(Material mat) {
    switch (mat) {
    case AIR:
      return true;
    }
    return false;
  }

  public static boolean isArmor(Material mat)
  {
    switch ($SWITCH_TABLE$org$bukkit$Material()[mat.ordinal()]) {
    case 87:
    case 207:
    case 208:
    case 209:
    case 210:
    case 211:
    case 212:
    case 213:
    case 214:
    case 215:
    case 216:
    case 217:
    case 218:
    case 219:
    case 220:
    case 221:
    case 222:
    case 223:
    case 224:
    case 225:
    case 226:
    case 227:
    case 228:
    case 229:
    case 230:
    case 231:
    case 232:
    case 233:
    case 234:
    case 235:
    case 236:
    case 237:
    case 238:
    case 239:
    case 240:
    case 241:
    case 242:
    case 243:
    case 244:
    case 245:
    case 246:
    case 247:
    case 248:
    case 249:
    case 250:
    case 251:
    case 252:
    case 253:
    case 254:
    case 255:
    case 256:
    case 257:
    case 258:
      return true;
    }
    return true;
  }

  public static void disarmCheck(Hero hero, Heroes plugin)
  {
    ItemStack[] contents = hero.getPlayer().getInventory().getContents();
    boolean changed = false;
    for (int i = 0; i < 9; i++)
      if (contents[i] != null)
      {
        if (isWeapon(contents[i].getType())) {
          moveItem(hero, i, contents[i]);
          changed = true;
        }
      }
    if (changed)
      syncInventory(hero.getPlayer(), plugin);
  }

  public static void moveFile(File from, File to)
  {
    if (!from.exists()) {
      return;
    }
    OutputStream output = null;
    InputStream input = null;
    try {
      to.getParentFile().mkdirs();
      to.createNewFile();
      output = new FileOutputStream(to, false);
      input = new FileInputStream(from);
      int out;
      while ((out = input.read()) != -1)
      {
        int out;
        output.write(out);
      }
      input.close();
      output.close();
      from.delete();
    } catch (Exception e) {
      e.printStackTrace();
      try
      {
        input.close();
        output.close();
      }
      catch (IOException localIOException)
      {
      }
    }
    finally
    {
      try
      {
        input.close();
        output.close();
      } catch (IOException localIOException1) {
      }
    }
  }

  public static int getMCExperience(int level) {
    return level * 7;
  }

  public static Integer toInt(Object val) {
    if ((val instanceof String))
      try {
        return Integer.valueOf((String)val);
      } catch (NumberFormatException e) {
        return null;
      }
    if (!(val instanceof Number)) {
      return null;
    }

    if ((val instanceof Integer))
      return (Integer)val;
    if ((val instanceof Double))
      return Integer.valueOf(((Double)val).intValue());
    if ((val instanceof Float))
      return Integer.valueOf(((Float)val).intValue());
    if ((val instanceof Long))
      return Integer.valueOf(((Long)val).intValue());
    if ((val instanceof BigDecimal)) {
      return Integer.valueOf(((BigDecimal)val).intValue());
    }
    return null;
  }

  public static int toIntNonNull(Object val, String name)
  {
    Integer newVal = toInt(val);
    if (newVal == null) {
      throw new IllegalArgumentException(name + " must be a numeral!");
    }
    return newVal.intValue();
  }

  public static double toDoubleNonNull(Object val, String name)
  {
    Double newVal = toDouble(val);
    if (newVal == null) {
      throw new IllegalArgumentException(name + " must be a numeral!");
    }
    return newVal.doubleValue();
  }

  public static boolean isFood(Material mat)
  {
    switch ($SWITCH_TABLE$org$bukkit$Material()[mat.ordinal()]) {
    case 169:
    case 191:
    case 206:
    case 260:
    case 261:
    case 263:
    case 290:
    case 291:
    case 298:
    case 301:
    case 304:
    case 305:
    case 306:
    case 307:
    case 308:
    case 316:
    case 332:
    case 333:
    case 334:
    case 335:
    case 337:
    case 341:
      return true;
    }
    return false;
  }

  public static Double toDouble(Object val)
  {
    if ((val instanceof String))
      try {
        return Double.valueOf((String)val);
      } catch (NumberFormatException e) {
        return null;
      }
    if (!(val instanceof Number)) {
      return null;
    }

    if ((val instanceof Integer))
      return Double.valueOf(((Integer)val).doubleValue());
    if ((val instanceof Double))
      return (Double)val;
    if ((val instanceof Float))
      return Double.valueOf(((Float)val).doubleValue());
    if ((val instanceof Long))
      return Double.valueOf(((Long)val).doubleValue());
    if ((val instanceof BigDecimal)) {
      return Double.valueOf(((BigDecimal)val).doubleValue());
    }
    return null;
  }

  public static String stringDouble(double d)
  {
    return String.valueOf(formatDouble(d));
  }

  public static double formatDouble(double d) {
    int val = (int)(d * 1000.0D);
    return val / 1000.0D;
  }

  public static ItemStack itemFromString(String[] vals, int amount) {
    ItemStack stack = null;
    try {
      int id = Integer.parseInt(vals[0]);
      byte sub = 0;
      if (vals.length > 1) {
        sub = (byte)Integer.parseInt(vals[1]);
      }
      stack = new ItemStack(id, amount, (short)sub);
    } catch (NumberFormatException localNumberFormatException) {
    }
    return stack;
  }

  public static int getFeatherFallLevel(PlayerInventory inv) {
    int level = 0;
    for (ItemStack armor : inv.getArmorContents()) {
      if ((armor != null) && (armor.containsEnchantment(Enchantment.PROTECTION_FALL)))
      {
        level += armor.getEnchantmentLevel(Enchantment.PROTECTION_FALL);
      }
    }
    return level;
  }

  public static final double nextRand()
  {
    return rand.nextInt(10000) / 10000.0D;
  }

  public static final int nextInt(int max) {
    return rand.nextInt(max);
  }
}
